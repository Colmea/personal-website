/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useState } from 'react'
import { useLoader, useFrame } from 'react-three-fiber'
import { GLTFLoader, GLTF } from 'three/examples/jsm/loaders/GLTFLoader'
import { CubeTextureLoader } from 'three'

type GLTFResult = GLTF & {
  nodes: {
    ['Cube.001_0']: THREE.Mesh
    ['Cube.001_1']: THREE.Mesh
    ['Cube.002_0']: THREE.Mesh
    ['Cube.002_1']: THREE.Mesh
    ['Cube.002_2']: THREE.Mesh
    ['Cube.006_Cube.012_0']: THREE.Mesh
    ['Cube.006_Cube.012_1']: THREE.Mesh
    BezierCurve_BezierCurve001: THREE.Mesh
    BezierCurve001_BezierCurve002: THREE.Mesh
  }
  materials: {
    ['Material.003']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.001']: THREE.MeshStandardMaterial
    ['Material.006']: THREE.MeshStandardMaterial
    ['Material.015']: THREE.MeshStandardMaterial
  }
}

export default function Model(props: JSX.IntrinsicElements['group']) {
  const group = useRef<THREE.Group>();
  const screenRef = useRef<THREE.Group>();
  const [screenDirectionIsDown, setScreenDirectionIsDown] = useState(true);

  const { nodes, materials } = useLoader<GLTFResult>(GLTFLoader, '/screen-2.glb');

  // Load CubeTexture for env map
  const cubeTexture = useLoader(CubeTextureLoader, [[
    'envmap/px.jpg',
    'envmap/nx.jpg',
    'envmap/py.jpg',
    'envmap/ny.jpg',
    'envmap/pz.jpg',
    'envmap/nz.jpg'
  ]]);
  cubeTexture.format = THREE.RGBFormat;

  // Set env map for each material
  Object.values(materials).forEach(material => {
    material.envMap = cubeTexture[0];
  });

  // Update screen position
  const speed = 0.05;
  useFrame((state, delta) => {
    const currentRotation = screenRef.current.rotation;
    screenRef.current.rotation.x += delta * (screenDirectionIsDown ? speed : -speed);

    if (screenDirectionIsDown && currentRotation.x > 1.70) {
      setScreenDirectionIsDown(false);
    }
    else if (!screenDirectionIsDown && currentRotation.x < 1.5) {
      setScreenDirectionIsDown(true);
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group position={[-2.1, -0.23, -0.48]} rotation={[Math.PI / 2, 0, -3.14]}>
        <mesh material={materials['Material.003']} geometry={nodes['Cube.001_0'].geometry} />
        <mesh material={materials['Material.002']} geometry={nodes['Cube.001_1'].geometry} />
      </group>
      <group position={[-2.1, -0.23, -0.48]} rotation={[Math.PI / 2, 0, -3.14]}>
        <mesh material={materials['Material.001']} geometry={nodes['Cube.002_0'].geometry} />
        <mesh material={materials['Material.002']} geometry={nodes['Cube.002_1'].geometry} />
        <mesh material={materials['Material.003']} geometry={nodes['Cube.002_2'].geometry} />
      </group>
      <group ref={screenRef} position={[-2.1, -0.23, -0.48]} rotation={[Math.PI / 2, 0, -3.14]}>
        <mesh material={materials['Material.003']} geometry={nodes['Cube.006_Cube.012_0'].geometry} />
        <mesh material={materials['Material.006']} geometry={nodes['Cube.006_Cube.012_1'].geometry} />
      </group>
      <mesh
        material={materials['Material.015']}
        geometry={nodes.BezierCurve_BezierCurve001.geometry}
        position={[-2.1, -0.23, -0.48]}
        rotation={[Math.PI / 2, 0, -3.14]}
      />
      <mesh
        material={materials['Material.015']}
        geometry={nodes.BezierCurve001_BezierCurve002.geometry}
        position={[-2.1, -0.23, -0.48]}
        rotation={[Math.PI / 2, 0, -3.14]}
      />
    </group>
  )
}
