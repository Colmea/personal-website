/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useState, useEffect } from 'react'
import { useLoader, useFrame } from 'react-three-fiber'
import { GLTFLoader, GLTF } from 'three/examples/jsm/loaders/GLTFLoader'
import { CubeTextureLoader } from 'three'
import { getMouseDegrees } from '../../utils/mouseUtils';


type Props = {
  mousePosition: { x: number, y: number };
};

type GLTFResult = GLTF & {
  nodes: {
    ['Cube.001_0']: THREE.Mesh
    ['Cube.001_1']: THREE.Mesh
    ['Cube.002_0']: THREE.Mesh
    ['Cube.002_1']: THREE.Mesh
    ['Cube.002_2']: THREE.Mesh
    ['Cube.006_Cube.012_0']: THREE.Mesh
    ['Cube.006_Cube.012_1']: THREE.Mesh
    BezierCurve_BezierCurve001: THREE.Mesh
    BezierCurve001_BezierCurve002: THREE.Mesh
  }
  materials: {
    ['Material.003']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    ['Material.001']: THREE.MeshStandardMaterial
    ['Material.006']: THREE.MeshStandardMaterial
    ['Material.015']: THREE.MeshStandardMaterial
  }
}

export default function Model(props: Props & JSX.IntrinsicElements['group'] ) {
  const group = useRef<THREE.Group>();
  const screenRef = useRef<THREE.Group>();
  const { nodes, materials } = useLoader<GLTFResult>(GLTFLoader, '/screen-2.glb');
  const screenDefaultRotation = useRef<THREE.Euler>();

  
  // Load CubeTexture for env map
  const cubeTexture = useLoader(CubeTextureLoader, [[
    '/envmap/px.jpg',
    '/envmap/nx.jpg',
    '/envmap/py.jpg',
    '/envmap/ny.jpg',
    '/envmap/pz.jpg',
    '/envmap/nz.jpg'
  ]]);

  cubeTexture.format = THREE.RGBFormat;

  // Set env map for each material
  Object.values(materials).forEach(material => {
    material.envMap = cubeTexture[0];
  });

  // Get degress based on mouse position on screen
  let degrees = getMouseDegrees(props.mousePosition.x, props.mousePosition.y, 40);

  useEffect(() => {
    screenDefaultRotation.current = screenRef.current.rotation.clone();
  }, []);

  // Update screen position
  const speed = 0.05;
  // useFrame((state, delta) => {
  //   if (screenDefaultRotation.current) {
  //     const rotationFactor = 0.1;

  //     const currentZDeg = THREE.MathUtils.radToDeg(screenDefaultRotation.current.z);
  //     const currentXDeg = THREE.MathUtils.radToDeg(screenDefaultRotation.current.x);

  //     screenRef.current.rotation.x = THREE.Math.degToRad(currentXDeg + (degrees.y * rotationFactor));
  //     screenRef.current.rotation.z = THREE.Math.degToRad(currentZDeg - (degrees.x * rotationFactor));
  //   }
  // });

  return (
    <group ref={group} {...props} dispose={null}>
      <group position={[-2.1, -0.23, -0.48]} rotation={[Math.PI / 2, 0, -3.14]}>
        <mesh material={materials['Material.003']} geometry={nodes['Cube.001_0'].geometry} />
        <mesh material={materials['Material.002']} geometry={nodes['Cube.001_1'].geometry} />
      </group>
      <group position={[-2.1, -0.23, -0.48]} rotation={[Math.PI / 2, 0, -3.14]}>
        <mesh material={materials['Material.001']} geometry={nodes['Cube.002_0'].geometry} />
        <mesh material={materials['Material.002']} geometry={nodes['Cube.002_1'].geometry} />
        <mesh material={materials['Material.003']} geometry={nodes['Cube.002_2'].geometry} />
      </group>
      <group ref={screenRef} position={[-2.1, -0.23, -0.48]} rotation={[Math.PI / 2, 0, -3.14]}>
        <mesh material={materials['Material.003']} geometry={nodes['Cube.006_Cube.012_0'].geometry} />
        <mesh material={materials['Material.006']} geometry={nodes['Cube.006_Cube.012_1'].geometry} />
      </group>
      <mesh
        material={materials['Material.015']}
        geometry={nodes.BezierCurve_BezierCurve001.geometry}
        position={[-2.1, -0.23, -0.48]}
        rotation={[Math.PI / 2, 0, -3.14]}
      />
      <mesh
        material={materials['Material.015']}
        geometry={nodes.BezierCurve001_BezierCurve002.geometry}
        position={[-2.1, -0.23, -0.48]}
        rotation={[Math.PI / 2, 0, -3.14]}
      />
    </group>
  )
}
